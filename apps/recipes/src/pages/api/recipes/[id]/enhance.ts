import type { APIRoute } from 'astro'
import { Type as SchemaType } from '@google/genai'
import { initGeminiClient, serverErrorResponse } from '../../../../lib/api-helpers'
import { db } from '../../../../lib/firebase-server'
import type { Recipe, IngredientGroup, StructuredStep, Ingredient } from '../../../../lib/types'

const ENHANCE_SYSTEM_PROMPT = `
You are a cooking expert analyzing a recipe to enhance its structure for display.

Given the recipe's title, ingredients, and steps, generate:

1. INGREDIENT GROUPS:
   - **Mise-en-Place Flow**: Organize by CHRONOLOGICAL order of use in the recipe.
   - **Logical Sections**: Group by component (e.g., "FOR THE DUXELLES", "FOR THE SAUCE").
   - **Header Format**: Short, ALL-CAPS (e.g., "FOR THE PASTA").
   - **Strict Mapping**: Every ingredient must belong to a group.

2. STRUCTURED STEPS:
   - For each step, create:
     • title: Short action name (2-4 words, e.g., "Sear the Shrimp")
     • text: The original instruction (keep as-is)
     • highlightedText: The original instruction with key cooking action verbs wrapped in **bold** markdown (e.g., "**Whisk** the eggs until fluffy", "**Add** the onions and **sauté**")
     • tip: Extract any pro-tips or warnings (null if none)

Return JSON matching the schema.
`

const responseSchema = {
  type: SchemaType.OBJECT as const,
  properties: {
    ingredientGroups: {
      type: SchemaType.ARRAY as const,
      items: {
        type: SchemaType.OBJECT as const,
        properties: {
          header: { type: SchemaType.STRING as const },
          startIndex: { type: SchemaType.NUMBER as const },
          endIndex: { type: SchemaType.NUMBER as const },
        },
        required: ['header', 'startIndex', 'endIndex'] as const,
      },
    },
    structuredSteps: {
      type: SchemaType.ARRAY as const,
      items: {
        type: SchemaType.OBJECT as const,
        properties: {
          title: { type: SchemaType.STRING as const, nullable: true },
          text: { type: SchemaType.STRING as const },
          highlightedText: { type: SchemaType.STRING as const },
          tip: { type: SchemaType.STRING as const, nullable: true },
        },
        required: ['text', 'highlightedText'] as const,
      },
    },
  },
  required: ['ingredientGroups', 'structuredSteps'] as const,
}

export const POST: APIRoute = async ({ params, locals }) => {
  const recipeId = params.id

  if (!recipeId) {
    return new Response(JSON.stringify({ error: 'Recipe ID required' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    })
  }

  let client
  try {
    client = await initGeminiClient(locals)
  } catch {
    return serverErrorResponse('Missing API Key configuration')
  }

  try {
    // Fetch the recipe from Firestore using the shared db proxy
    const recipe = (await db.getDocument('recipes', recipeId)) as Recipe | null

    if (!recipe) {
      return new Response(JSON.stringify({ error: 'Recipe not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    // If already enhanced, return existing data
    if (recipe.ingredientGroups?.length && recipe.structuredSteps?.length) {
      return new Response(
        JSON.stringify({
          success: true,
          data: {
            ingredientGroups: recipe.ingredientGroups,
            structuredSteps: recipe.structuredSteps,
          },
          cached: true,
        }),
        {
          status: 200,
          headers: { 'Content-Type': 'application/json' },
        },
      )
    }

    // Build prompt with recipe data
    const ingredientsList = recipe.ingredients
      .map((ing: Ingredient, idx: number) =>
        `${idx}: ${ing.amount || ''} ${ing.name}${ing.prep ? ` (${ing.prep})` : ''}`.trim(),
      )
      .join('\n')

    const stepsList = recipe.steps
      .map((step: string, idx: number) => `Step ${idx + 1}: ${step}`)
      .join('\n')

    const prompt = `Recipe: ${recipe.title}

INGREDIENTS (with 0-based indices):
${ingredientsList}

STEPS:
${stepsList}

Generate ingredientGroups (using startIndex/endIndex to reference ingredients) and structuredSteps.`

    // Call Gemini
    const response = await client.models.generateContent({
      model: 'gemini-2.5-flash',
      config: {
        responseMimeType: 'application/json',
        responseSchema,
      },
      contents: [
        {
          role: 'user',
          parts: [{ text: ENHANCE_SYSTEM_PROMPT }, { text: prompt }],
        },
      ],
    })

    const resultText = response.text
    if (!resultText) {
      throw new Error('No content generated by Gemini')
    }

    const enhancedData = JSON.parse(resultText) as {
      ingredientGroups: IngredientGroup[]
      structuredSteps: StructuredStep[]
    }

    // Save to Firestore for caching
    await db.updateDocument('recipes', recipeId, {
      ingredientGroups: enhancedData.ingredientGroups,
      structuredSteps: enhancedData.structuredSteps,
      updatedAt: new Date().toISOString(),
    })

    return new Response(
      JSON.stringify({
        success: true,
        data: enhancedData,
        cached: false,
      }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      },
    )
  } catch (error: unknown) {
    console.error('Enhance Error:', error)
    const message = error instanceof Error ? error.message : 'Failed to enhance recipe'
    return new Response(JSON.stringify({ error: message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    })
  }
}
