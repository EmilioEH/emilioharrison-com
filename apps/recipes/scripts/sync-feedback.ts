import fs from 'fs'
import path from 'path'
import type { Feedback } from '../src/lib/types'

// This script simulates fetching feedback from the API/KV and writing it to documentation.
// In a real environment, it would use fetch() with authentication.

const OPEN_REPORTS_PATH = path.join(process.cwd(), 'docs/feedback/open-reports.md')
const ALL_REPORTS_PATH = path.join(process.cwd(), 'docs/feedback/all-reports.md')

async function syncFeedback() {
  console.log('ðŸ”„ Syncing feedback from Chefboard...')

  try {
    let feedbackList: Feedback[] = []

    // Try remote D1 first (production)
    try {
      const { execSync } = await import('child_process')
      console.log('â˜ï¸  Attempting fetch from Remote Production D1...')

      const tempFile = path.join(process.cwd(), 'temp_feedback.json')
      try {
        execSync(
          `npx wrangler d1 execute recipes-db --remote -y --command "SELECT * FROM feedback ORDER BY timestamp DESC" --json > "${tempFile}"`,
          { encoding: 'utf-8', stdio: 'inherit', env: { ...process.env, CI: 'true' } },
        )

        if (fs.existsSync(tempFile)) {
          const d1Output = fs.readFileSync(tempFile, 'utf-8')
          fs.unlinkSync(tempFile)

          const parsedOutput = JSON.parse(d1Output)
          const rows = parsedOutput[0]?.results || []
          feedbackList = parseRows(rows)
          console.log(`âœ… Retrieved ${feedbackList.length} items from Remote D1`)
        } else {
          throw new Error('Output file not created')
        }
      } catch (e) {
        console.error('DEBUG: Remote sync via file failed', e)
        if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile)
        throw e
      }
    } catch (remoteErr) {
      console.error('DEBUG: Remote D1 Error Details:', remoteErr)
      console.log('âš ï¸  Remote D1 failed. Attempting fetch from Local D1...')
      try {
        const { execSync } = await import('child_process')
        const d1Output = execSync(
          'npx wrangler d1 execute recipes-db --local --command "SELECT * FROM feedback ORDER BY timestamp DESC" --json',
          { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'ignore'] },
        )
        const parsedOutput = JSON.parse(d1Output)
        const rows = parsedOutput[0]?.results || []
        feedbackList = parseRows(rows)
        console.log(`âœ… Retrieved ${feedbackList.length} items from Local D1`)
      } catch (localErr) {
        console.error('âŒ Both remote and local D1 failed.')
        feedbackList = getMockData()
      }
    }

    // Split lists
    const openFeedback = feedbackList.filter((f) => !f.status || f.status === 'open')

    console.log(`ðŸ“ Writing reports: ${openFeedback.length} Open, ${feedbackList.length} Total`)

    await generateMarkdown(openFeedback, OPEN_REPORTS_PATH, 'Open Feedback Reports')
    await generateMarkdown(feedbackList, ALL_REPORTS_PATH, 'All Feedback Reports')

    console.log('âœ… Sync complete.')
  } catch (error) {
    console.error('âŒ Sync failed:', error)
  }
}

function parseRows(rows: any[]): Feedback[] {
  return rows.map((row: any) => {
    let logs = []
    let context = {}

    if (row.logs && !row.logs.startsWith('[') && !row.logs.startsWith('r2:')) {
      logs = row.logs
    } else if (row.logs && row.logs !== '[]') {
      try {
        logs = JSON.parse(row.logs)
      } catch {
        logs = row.logs
      }
    }

    if (row.context && !row.context.startsWith('{') && !row.context.startsWith('r2:')) {
      context = row.context
    } else if (row.context && row.context !== '{}') {
      try {
        context = JSON.parse(row.context)
      } catch {
        context = row.context
      }
    }

    return {
      ...row,
      logs,
      context,
    }
  })
}

function getMockData(): Feedback[] {
  return [
    {
      id: 'mock-1',
      timestamp: new Date().toISOString(),
      type: 'bug',
      description: "The 'This Week' counter doesn't update immediately.",
      expected: 'Counter should show 1 after adding a recipe.',
      actual: 'Counter stayed at 0 until refresh.',
      screenshot: undefined,
      logs: [],
      context: {
        url: '/protected/recipes',
        userAgent: 'Mozilla/5.0...',
        user: 'emilio',
        appState: '{}',
      },
      status: 'open',
    },
  ]
}

async function generateMarkdown(list: Feedback[], filePath: string, title: string) {
  const IMAGES_DIR = path.join(path.dirname(filePath), 'images')
  if (!fs.existsSync(IMAGES_DIR)) {
    fs.mkdirSync(IMAGES_DIR, { recursive: true })
  }

  let markdown = `# ${title}\n\n`
  markdown += `> [!NOTE]\n`
  markdown += `> This file is auto-generated by \`scripts/sync-feedback.ts\`. Last synced: ${new Date().toLocaleString()}\n\n`

  if (list.length === 0) {
    markdown += `No reports found.`
    fs.writeFileSync(filePath, markdown)
    return
  }

  for (const report of list) {
    const date = new Date(report.timestamp).toLocaleString()
    const statusIcon = report.status === 'fixed' ? 'âœ…' : report.status === 'wont-fix' ? 'ðŸš«' : 'ðŸ”´'
    const statusText = report.status ? report.status.toUpperCase() : 'OPEN'

    markdown += `## [${statusIcon} ${statusText}] ${report.type.toUpperCase()} - ${date}\n`
    markdown += `**ID**: \`${report.id}\` | **User**: \`${report.context.user || 'Unknown'}\`\n\n`

    if (report.type === 'bug') {
      markdown += `### Description\n> **Actual**: ${report.actual}\n> **Expected**: ${report.expected}\n\n`
    } else {
      markdown += `### Feature Request\n${report.description}\n\n`
    }

    // Technical Details
    markdown += `<details>\n<summary>Technical Context</summary>\n\n`
    markdown += `- **URL**: ${report.context.url}\n`
    if (report.resolved_at) {
      markdown += `- **Resolved At**: ${new Date(report.resolved_at).toLocaleString()}\n`
    }

    markdown += `\n**Recent Logs**:\n\`\`\`json\n${JSON.stringify(report.logs, null, 2)}\n\`\`\`\n\n`
    markdown += `</details>\n\n`

    // Screenshot handling
    if (report.screenshot) {
      markdown += `### Screenshot\n`
      if (report.screenshot.startsWith('data:image')) {
        try {
          const base64Data = report.screenshot.replace(/^data:image\/\w+;base64,/, '')
          const buffer = Buffer.from(base64Data, 'base64')
          const imageFilename = `${report.id}.png`
          const imagePath = path.join(IMAGES_DIR, imageFilename)
          fs.writeFileSync(imagePath, buffer)
          markdown += `![Feedback Image](./images/${imageFilename})\n\n`
        } catch (e) {}
      } else if (report.screenshot.startsWith('r2:')) {
        markdown += `> Stored in R2: \`${report.screenshot}\`\n\n`
      } else {
        markdown += `![Feedback Image](${report.screenshot})\n\n`
      }
    }

    markdown += `---\n\n`
  }

  fs.writeFileSync(filePath, markdown)
}

syncFeedback()
