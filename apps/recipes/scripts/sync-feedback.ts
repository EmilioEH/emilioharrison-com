import fs from 'fs'
import path from 'path'
import admin from 'firebase-admin'
import { getFirestore } from 'firebase-admin/firestore'
import { getStorage } from 'firebase-admin/storage'
import type { Feedback } from '../src/lib/types'

import type { ServiceAccount } from 'firebase-admin'

// JSON import
import serviceAccount from '../firebase-service-account.json'

if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount as ServiceAccount),
    storageBucket: `${serviceAccount.project_id}.firebasestorage.app`,
  })
}

const db = getFirestore()
const bucket = getStorage().bucket()

const OPEN_REPORTS_PATH = path.join(process.cwd(), 'docs/feedback/open-reports.md')
const ALL_REPORTS_PATH = path.join(process.cwd(), 'docs/feedback/all-reports.md')

async function syncFeedback() {
  console.log('ðŸ”„ Syncing feedback from Chefboard (Firebase)...')

  try {
    const snapshot = await db.collection('feedback').orderBy('timestamp', 'desc').get()
    const feedbackList = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }) as Feedback)

    console.log(`âœ… Retrieved ${feedbackList.length} items from Firestore`)

    // Split lists
    const openFeedback = feedbackList.filter((f) => !f.status || f.status === 'open')

    console.log(`ðŸ“ Writing reports:`)
    console.log(`   - Open: ${OPEN_REPORTS_PATH} (${openFeedback.length} items)`)
    console.log(`   - All:  ${ALL_REPORTS_PATH} (${feedbackList.length} items)`)

    await generateMarkdown(openFeedback, OPEN_REPORTS_PATH, 'Open Feedback Reports')
    await generateMarkdown(feedbackList, ALL_REPORTS_PATH, 'All Feedback Reports')

    console.log('âœ… Sync complete.')
  } catch (error) {
    console.error('âŒ Sync failed:', error)
  }
}

async function generateMarkdown(list: Feedback[], filePath: string, title: string) {
  const IMAGES_DIR = path.join(path.dirname(filePath), 'images')
  if (!fs.existsSync(IMAGES_DIR)) {
    fs.mkdirSync(IMAGES_DIR, { recursive: true })
  }

  let markdown = `# ${title}\n\n`
  markdown += `> [!NOTE]\n`
  markdown += `> This file is auto-generated by \`scripts/sync-feedback.ts\`. Last synced: ${new Date().toLocaleString()}\n\n`

  if (list.length === 0) {
    markdown += `No reports found.`
    fs.writeFileSync(filePath, markdown)
    return
  }

  for (const report of list) {
    const date = new Date(report.timestamp).toLocaleString()
    const statusIcon = report.status === 'fixed' ? 'âœ…' : report.status === 'wont-fix' ? 'ðŸš«' : 'ðŸ”´'
    const statusText = report.status ? report.status.toUpperCase() : 'OPEN'

    // Parse context from JSON string (stored as string in Firestore to avoid nested entity errors)
    let context: Record<string, unknown> = {}
    try {
      context =
        typeof report.context === 'string' ? JSON.parse(report.context) : report.context || {}
    } catch {
      context = {}
    }

    // Parse logs from JSON string
    let logs: unknown[] = []
    try {
      logs = typeof report.logs === 'string' ? JSON.parse(report.logs) : report.logs || []
    } catch {
      logs = []
    }

    markdown += `## [${statusIcon} ${statusText}] ${report.type.toUpperCase()} - ${date}\n`
    markdown += `**ID**: \`${report.id}\` | **User**: \`${(context.user as string) || 'Unknown'}\`\n\n`

    if (report.type === 'bug') {
      markdown += `### Description\n> **Actual**: ${report.actual}\n> **Expected**: ${report.expected}\n\n`
    } else {
      markdown += `### Feature Request\n${report.description}\n\n`
    }

    // Technical Details
    markdown += `<details>\n<summary>Technical Context</summary>\n\n`
    markdown += `- **URL**: ${(context.url as string) || 'Unknown'}\n`
    if (report.resolved_at) {
      markdown += `- **Resolved At**: ${new Date(report.resolved_at).toLocaleString()}\n`
    }

    markdown += `\n**Recent Logs**:\n\`\`\`json\n${JSON.stringify(logs, null, 2)}\n\`\`\`\n\n`
    markdown += `</details>\n\n`

    // Screenshot handling
    if (report.screenshot) {
      markdown += `### Screenshot\n`
      if (report.screenshot.startsWith('data:image')) {
        // Legacy base64 support
        try {
          const base64Data = report.screenshot.replace(/^data:image\/\w+;base64,/, '')
          const buffer = Buffer.from(base64Data, 'base64')
          const imageFilename = `${report.id}.png`
          const imagePath = path.join(IMAGES_DIR, imageFilename)
          fs.writeFileSync(imagePath, buffer)
          markdown += `![Feedback Image](./images/${imageFilename})\n\n`
        } catch (e) {}
      } else if (report.screenshot.startsWith('storage:')) {
        // New Storage reference
        // We could download it to images dir for local viewing
        const key = report.screenshot.replace('storage:', '')
        const imageFilename = `${report.id}.png`
        const imagePath = path.join(IMAGES_DIR, imageFilename)

        try {
          // Check if exists locally already
          if (!fs.existsSync(imagePath)) {
            console.log(`Downloading screenshot for ${report.id}...`)
            await bucket.file(key).download({ destination: imagePath })
          }
          markdown += `![Feedback Image](./images/${imageFilename})\n\n`
        } catch (e) {
          markdown += `> Failed to download screenshot: \`${key}\`\n\n`
        }
      } else if (report.screenshot.startsWith('r2:')) {
        markdown += `> Legacy R2 Reference: \`${report.screenshot}\`\n\n`
      } else {
        markdown += `![Feedback Image](${report.screenshot})\n\n`
      }
    }

    markdown += `---\n\n`
  }

  fs.writeFileSync(filePath, markdown)
}

syncFeedback()
